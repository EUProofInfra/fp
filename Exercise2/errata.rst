
************************
Errata to exercise set 2
************************



On printing and GHCi
====================

Q: ``'\n'`` doesn't work for me. What's the deal?

A: This is a result of the way GHCi handles strings. "Escape" characters
such as ``\n`` need to be interpreted to display as expected. GHCi doesn't
do this by default. To properly check your output, you need to wrap
your String in a relevant IO function; in this case ``putStrLn``. e.g. ::

        *Solution> lsTree (fibCreate 3)
        "dir3\n|\n|-- dir2\n|   |\n|   |-- dir1\n|   |   |\n|   |   |-- file\n|   |\n|   |-- file\n|\n|-- dir1\n|   |\n|   |-- file"
        *Solution> putStrLn $ lsTree (fibCreate 3)
        dir3
        |
        |-- dir2
        |   |
        |   |-- dir1
        |   |   |
        |   |   |-- file
        |   |
        |   |-- file
        |
        |-- dir1
        |   |
        |   |-- file
        *Solution> 

Note, however, that you cannot use IO functions in your file, or
our tests will fail to compile.


On "ambiguous occurence" and conflicting definitions
====================================================

Q: Data.List conflicts with the function `find` we are supposed to define.
Can we use Exercise.find to call our function?

A: Calling ``find`` must refer to the function we've asked you to define;
our tests will fail otherwise. To get around conflicting definitions, you
can either use a qualified import, or hide all conflicting definitions.
For a qualified import, use something like::

        import qualified Data.List as List

Then to use functions from Data.List, you preface it with List::

        foo = List.find blah

To hide conflicting definitions use (e.g.)::

        import DAta.List hiding (find)

To hide multiple functions, separate them with a comma::

        import DAta.List hiding (find,permutations)

Another alternative is to only import the functions you need::

        import DAta.List (permutations, scanl)

Finally, not directly relevant for this exercise, but if you only want to import typeclass instances from a module, you can give an empty list of functions to import::

        import Control.Monad ()

will only import typeclass instances from Control.Monad.


exampleEntry3
=============

The content should be ""


cd/cd1
======

* If given a file as "root", both cd ancd cd1 should return Nothing.
* If given an empty string "" (or []) for the path, you should return
  the root. You may

* assume that the same path does not refer to multiple entries. I.e.,
  assume that a directory only has one entry with a given name.


implode and explode
===================

Q: As the doc states, ::

        implode (explode s) = s

yet I'm not sure this is 100% possible. In the case of
implode(explode("a//a")) or ..("/a/")..
information is lost regarding the previous existence of leading,
trailing and double slashes (in the case that they are removed).

A: It is possible, and necessary. ;)
We recommend adding empty Strings to the path generated by explode;
e.g. ::

        explode "/a//a/" = ["", "a", "", "a", ""]

Don't forget to look at functions in Prelude and Data.List, as they
may be helpful.


lsL
===

Q: What should be output in the case of a directory?

A: Simply output the directory name. E.g., ::

        *Solution> putStr $ lsL (fibCreate 2)
        dir1
        size: 0 time: 0 file
        *Solution>

Here, the first line is a subdirectory, the second is a file.


lsTree
======

Q: should we print a trailing ``|`` after empty directories?

E.g., should we print (1)::

        root
        |
        |-- dir1
        |   |
        |   |-- dir1a
        |   |   |
        |   |   |-- dir1a1
        |   |   |
        |   |   |-- dir1a2
        |   |
        |   |-- dir1b

or (2)::

        root
        |
        |-- dir1
        |   |
        |   |-- dir1a
        |   |   |
        |   |   |-- dir1a1
        |   |   |   |
        |   |   |
        |   |   |-- dir1a2
        |   |   |   |
        |   |    
        |   |-- dir1b
        |   |   |


A: You should not print trailing '|', so (1) is correct.


cp
==


Q: If we attempt to cp an entry into a path which already exists, should
we replace files, merge directories, or simply insert the entry without
worrying if something already exists there?

A: Insert the entry as if there were no name conflict. (Thus, you will have
two entries with the same path). However:

1. You may assume that the ``root`` directory tree you are given contains
   no name conflicts prior to your cp, so multiple calls to cp may not
   behave properly.
2. If you are given an invalid path (e.g., your path refers to a file,
   or to nowhere in the tree), you should return the original Entry

rm
==

Q: If given an empty path should we return an error, or delete everything
within that directory? If a file is found with the same name, but
there is more to the path, should we return an error or delete everyting
in that file?

A: On an empty path, delete nothing. If there is nothing in the filetree
at the specified path (e.g., you encounter a file before exhausting
the path) you should do nothing.

Q: do we remove all entries in a directory, or remove the directory?
E.g., if the path is ["Documents","User1"], do I remove the directory
"User1", or remove all its entries?

Q: Do the entries to be deleted only appear at the end of the path?

A: Remove the entry (directory or file) refered to by the path--the 
expected behavior is like "rm -rf" in unix. If you are deleting a
directory, its sub-directories should be deleted with it (this
should happen automatically if you delete correctly).


sortTree
========

Q: Are we meant to be writing our own instance of Ord?

A: No, just the sortTree function.
Note that there are ways to do this using Ord, even without your
own instance.


Q: Is it ok if we sort the directories and then the files?

A: No, sorry; the test bench expects the directory to be sorted by name.
However, you may assume that there is only one entry with a given name
in the directory.


modifyEntries
=============

Q: What are we supposed to do for modifyEntries?
[insert remark about cryptic description]
  

A: Sorry... the description refers to an exercise which has been removed,
and we failed to update the description to reflect this. The intent is
to create a higher-order function which can be used to update all files
in a file tree according to some update function. The update function
can update both the name and properties of each file.


fibCreate
=========

Q: Shouldn't dir2 in the directories above fibCreate contain another
file?

A: Yes. the example should be::

        dir3
        |   
        |-- dir2
        |   |
        |   |-- dir1
        |   |   |
        |   |   |-- file, size 0, time 0, content 0
        |   |   
        |   |
        |   |-- file, size 0, time 0, content 0
        |
        |-- dir1
        |   |
        |   |-- file, size 0, time 0, content 0

NB: You can use this to give a slick 1-line definition of fibEntry.

